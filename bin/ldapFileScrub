#! /usr/local/bin/python

import sys
import os
import ldap
import subprocess
from optparse import OptionParser
import time

sys.path.append(os.path.realpath(os.path.join(__file__, '..', '..', 'conf')))
from ldapConf import *
from ldapUtil import *


##################################################################################
# global constants
##################################################################################
version="%prog: 2012-09-26"
modifiedBy="Garry Thuna"


##################################################################################
# parse command line options
##################################################################################
usage = "usage: %prog [options]" 
description = "Checks local server for workspaces that have either gtwsPurgeHours" +\
              " set and/or have recycle bins.  Search these directories for files" +\
              " that are older than the amount set by these attributes.  Removal is" +\
              " done recursively but directories that belong to sub-workspaces are" +\
              " excluded. Afterward a search is made for empty directories and any" +\
              " found are removed without regard to age."
parser = OptionParser(usage=usage, version=version, description=description)
parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False,
                        help="show changes made to file system [default: %default]")
(options, args) = parser.parse_args()


##################################################################################
# utils
##################################################################################
def getChildrenRelativePaths(con, parentDN):
    # get the relative path from all immediate children
    baseDN = parentDN
    filter = '(objectClass=gtWorkspace)'
    attrs  = [ 'gtwsRelativePath' ]
    childrenWorkspaces = con.search_s( baseDN, ldap.SCOPE_ONELEVEL, filter, attrs )

    childrenRelativePaths = list()
    for cws in childrenWorkspaces:
        childrenRelativePaths.append( cws[1]['gtwsRelativePath'][0] )
    return childrenRelativePaths


def scrubDir(path, maxAge, minDepth, childrenRelativePaths):
    nowTime = time.time()                            # time the search starts
    baseDepth = path.count(os.path.sep)
    print "xxx", path
    for curPath, dirs, files in os.walk(path):
        if options.verbose:
            print "scrubbing:  ", curPath
        curDepth = curPath.count(os.path.sep)
        if curDepth == baseDepth:                # at base of search
            for child in childrenRelativePaths:
                if options.verbose:
                    print "    skipping subworkspac:  ", child
                dirs.remove(child)               # skip child workspaces

        # honor gtwsPurgeMinDepth (we add one to the curDepth because on each
        # iteration we are checking the children of curPath and not curPath itself
        if curDepth + 1 - baseDepth < minDepth: 
            continue

        # check the age of the files
        for f in files:
            ff = os.path.join(curPath, f)
            ff_time = os.stat(ff).st_mtime
            age = (nowTime - ff_time)
            if age > maxAge:
                if options.verbose:
                    print "    deleting file: ", ff
                os.unlink(ff)
                files.remove(f)

        # see if the directory is empty (this is a lazy directory cleanup as 
        # empty ancestors don't get deleted until the next rerun of this script)
        if (len(dirs) + len(files) == 0) and (curDepth - baseDepth >= minDepth):

            if options.verbose:
                print "    directory is now empty... deleting "
            os.rmdir(curPath)

             
#def scrubRecycleBin(path, recycleBinDays):
#    # When files are deleted through samba it appears as though they are actually
#    # moved into the recycleBin (and renamed if necessary to avoid collistion). As
#    # such the files modification timestamp will not be updated to show the time of
#    # deletion but will retain the pre-deleted timestamp.  As we only want to purge
#    # files that have existed in the recycleBin in excess of a given time we mark
#    # the arrival of each file by creating a symlink to it.  The modification time
#    #   of the symlink can then be used to age the file.
#    script = '''#! /bin/sh
#        rDir="{rDir}"
#        maxDays={maxDays}
#        VERBOSE={verbose}
#        mkdir -p $rDir/.ageLinks  2>/dev/null
#    
#        # attempt to create a symlink for each file
#        [ "$VERBOSE" -gt 0 ] && echo "    aging contents of $rDir"
#        find $rDir -type f | while read fname; do
#            case {localOS} in
#                bsd) 
#                    ln -s "$fname" $rDir/.ageLinks/`echo $fname | sha1` 2>/dev/null
#                    ;;
#                linux)
#                    ln -s "$fname" $rDir/.ageLinks/`echo $fname | sha1sum | cut -d ' ' -f 1` 2>/dev/null
#                    ;;
#            esac
#        done
#
#        # delete the file pointed to by any symlink that is too old
#        [ "$VERBOSE" -gt 0 ] && echo "    deleting old files"
#        find $rDir/.ageLinks -type l -mtime +${maxDays} | while read fname; do
#            refName="`readlink $fname`"
#            [ "$VERBOSE" -gt 0 ] && echo "        $refName"
#            rm -f "$refName"
#            rm -f $fname
#        done
#    
#        # delete any empty directories including the rDir itself
#        find -d $rDir -type d -empty -delete
#
#    '''.format(localOS=LOCAL_OS
#             , rDir=path,
#             , maxDays=recycleBinDays
#             , verbose=int(options.verbose)
#            )
#    fd, fname = tempfile.mkstemp()
#    try:
#        with open(fname, 'w') as f:
#            f.write(script)
#        cmd = [ '/bin/sh', fname ]
#        if options.verbose: 
#            print 'scrubbing ' + path
#            p = subprocess.Popen(cmd); p.wait()
#        else:
#            with open('/dev/null', 'w') as f:
#                p = subprocess.Popen(cmd, stdout=f); p.wait()
#    finally:
#        os.unlink(fname)


def scrubRecycleBin(path, recycleBinDays):
    cmd1 = [ 'find', path, '-d', '-type', 'f', '-mtime', '+{0}'.format(recycleBinDays), '-print', '-delete' ]
    cmd2 = [ 'find', path, '-d', '-empty', '-print', '-delete' ]
        if options.verbose: 
            print 'scrubbing ' + path
            p = subprocess.Popen(cmd1); p.wait()
            p = subprocess.Popen(cmd2); p.wait()
        else:
            with open('/dev/null', 'w') as f:
                p = subprocess.Popen(cmd1, stdout=f); p.wait()
                p = subprocess.Popen(cmd2, stdout=f); p.wait()
    finally:
        os.unlink(fname)


##################################################################################
# main
##################################################################################
# bind to the ldap server 
con = ldap.initialize(BIND_URI)
if BIND_TLS:
    con.start_tls_s()
con.simple_bind_s(BIND_DN, BIND_PW)


#--------------
#- workspaces
#--------------
# get all workspaces on this server that have any of the following defined
#   gtwsPurgeHours  gtwsRecycleBinDays
baseDN = BASE_DN_SERVER
filter = '(&(objectClass=gtWorkspace)(|(gtwsPurgeHours=*)(gtwsRecycleBinDays=*)))'
attrs  = [ 'gtwsName', 'gtwsRecycleBinDays', 'gtwsPurgeHours', 'gtwsPurgeMinDepth' ]
workspaces = con.search_s( baseDN, ldap.SCOPE_SUBTREE, filter, attrs )

# for each workspace determine what needs to be cleaned up
for ws in workspaces:
    dn, attrs = ws
    path = os.path.join(SAMBA_WORKSPACE, SERVER_SHORT_NAME, getWorkspaceRelativePath(con, ws))

    if 'gtwsPurgeHours' in attrs:
        maxAge = int(attrs['gtwsPurgeHours'][0]) * 3600  # max age in seconds

        # calculate the working depth from the supplied gtwsPurgeMinDepth
        minDepth = 1
        if 'gtwsPurgeMinDepth' in attrs:
            minDepth = int(attrs['gtwsPurgeMinDepth'][0])

        # exclude directories of child workspaces
        childrenRelativePaths = getChildrenRelativePaths(con, dn)

        # do it
        scrubDir(path, maxAge, minDepth, childrenRelativePaths)

    if 'gtwsRecycleBinDays' in attrs:
        path = os.path.join(path, SAMBA_RECYCLE_DIR)
        maxAge = int(attrs['gtwsRecycleBinDays'][0]) * 24 * 3600   # max age in seconds
        scrubDir(path, maxAge, 0, [])
        scrubRecycleBin(path, maxAge):        


# cleanup
con.unbind_s()


#--------------
#- homes
#--------------
curPath, dirs, files in os.walk(SAMBA_HOME)
for userDir in dirs:
   rDir = os.path.join(curPath
                      ,userDir
                      ,SAMBA_USER_HOME
                      ,SAMBA_RECYCLE_DIR )
   #todo: parameterize duration
   scrubRecycleBin(rDir, 5):        



